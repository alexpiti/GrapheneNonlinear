function [sigma3_xxxx, sigma1_xx] = sigma3_Graphene_2015JLC( ...
    s3_Formulas, s3_Mode, omega, mu_eV, Temp, Gi_eV, Ge_eV )

% FUNCTION [sigma3_xxxx, sigma1_xx] = sigma3_Graphene_2015JLC( ...
%    s3_Formulas, s3_Mode, omega, mu_eV, Temp, Gi_eV, Ge_eV )
%
% MATLAB implementation of the formulas in [10.1103/PhysRevB.91.235320]
% (JinLuo Cheng et al., PRB, 2015) for the calculation of the complex 
% valued nonlinear surface conductivity sigma(3) in a perturbative regime. 
% The sigma3 value depends on frequency, chemical potential, finite 
% (nonzero) temperature, and finite relaxation rates; the latter can be 
% different for intraband and interband transitions. The function also 
% computes complex valued sigma(1).
%
%  --- Inputs -------------------------------------------------------------
%  * s3_Formulas : string denoting the formula-set to be used. Available
%                  choices are {'Full_xxxx','Full','Simple'}. See details
%                  below for what-is-what.
%  * s3_Mode : string controlling which nonlinear effect is to be modeled.
%              Available choices are {'THG','Kerr','KerrDetune','PFC'}. 
%              See details below for what-is-what
%  * omega : frequency in [rad/s]. Can be vector if mu_eV is scalar.
%  * mu_eV : chemical potential in [eV]. Can be vector if omega is scalar.
%  * Temp  : temperature in [K]. Scalar
%  * Gi_eV : intraband momentum relaxation rate in [eV]. Scalar. The
%            equivalent relaxation lifetime is tau=hbar/(G_eV*e), where e
%            is the electron charge.
%  * Ge_eV : interband momentum relaxation rate in [eV]. Scalar
% 
%  --- Outputs ------------------------------------------------------------
%  * sigma3_xxxx : Symmetrized (see details below) 3rd-order nonlinear 
%                  surface conductivity for xxxx-component of the tensor,
%                  in [S*(m/V)^2] units.
%  * sigma1_xx : (Optional) Linear surface conductivity of xx-component in
%                 [S] units. 
%
% === Details =============================================================
%
% This function uses the JLC formulas in [1], that go one step beyond 
% paper [2] by SAM, allowing nonzero temperature and unequal Gi and Ge
% (paper [2] treats zero temperature and finite Gi==Ge, i.e., equal 
% intra/inter-band rates. However, I should note that the formulas in [2] 
% are generally more stable (non divergent) and can, of course, be 
% converted to finite (nonzero) temperature.
%
% JLC [1] implementation deals with the full arbitrary case of (f1,f2,f2)
% frequency mix, for any tensor component. This function computes the
% SYMMETRIZED sigma3_xxxx tensor component of input parameter "omega" 
% (in [rad/sec]) or, equivalently, f (in [Hz]). Depending on the 
% "s3_Formulas" input argument, one can use the full formulas of [1] or the
% simplified versions for each case (e.g., Kerr or THG). The case used is
% controlled by the "s3_Mode" input argument (string):
%  * 'THG' (third-harmonic generation): The frequency 3*f is generated by
%     light (at f) interacting with graphene. This (f,f,f) mix of 
%     frequencies is the simplest nonlinearity case.
%  * 'Kerr': The "self-acting" f<->f effect, i.e., the (-f,f,f) mix. The
%     Kerr effect is quantified by the IMAG part of sigma3, which can be
%     self-focusing or defocusing, depending on the sign. The REAL part of
%     sigma3 gives rise to perturbative SA (saturable absorption) or IA 
%     (induced absorption, similar to TPA in bulk semiconductors), 
%     depending on the sign.
%  * 'KerrDetune': See below for details. 
%  * 'PFC' (Parametric Frequency Conversion): from the (-f,fp,fp) mix, 
%     where the output is at frequency 2*fp-f, with fp=const.
%
% In the Kerr case, note that the full formulas of JLC [1] diverge EXACTLY
% on f*(-1,1,1), i.e., the computed spectra are "noisy". For this, I
% recommend using 'KerrDetune' mode, i.e., a slightly detuned mix of
% frequencies: f*(e-1,1,1), where e = 1e-4. Using e-->0 (e.g., e=1e-6), 
% creates "noisy" (unstable) spectra; using higher e (e.g., e=1e-2) creates 
% smoothed-down spectra, i.e., any sharp Kerr resonances (useful in NL
% optics) are blurred out.
%
% Paper [1] by JLC also includes simplified formulas for the "pure" cases
% of THG and Kerr. The THG formulas are OK (meaning that the spectra they
% give are close to the ones acquired using the Full formulas), but the 
% Kerr ones have an error (in the "L3" term, Eq. (60) in [1], the units in
% the RHS don't check out). So, for Kerr effect, I recommend using the 
% full formulas at 'KerrDetune' s3_Mode, with the default e~1e-4, as 
% described above.
%
% Note that in the model assumed for gapless doped (mu>0) graphene, there's
% only 8 nonzero elements in the 4th-rank sigma3 tensor, and these 8 only 
% depend on 3 independent terms: {xxyy,xyxy,xyyx}. In all cases it holds 
% that xxxx=xxyy+xyxy+xyyx, plus the symmetry in swapping x<->y. Now, the
% formulas in the JLC [1] and SAM [2] paper are given for the UNsymmetrized
% sigma3_dabc(f1,f2,f3); to go to the SYMMETRIZED sigma3_dabc(f1,f2,f3),
% which is conventionally used in nonlinear optics, an "averaging" over the
% up-to-six concurrent permutations of the "dabc" coordinates and the 
% corresponding f_123 frequencies is required, e.g., Eq. (14) in [1]:
%
%    d;abc (1,2,3) = 1/6*( d;abc(1,2,3) + d;bca(2,3,1) + d;cab(3,1,2) ...
%                          d;acb(1,3,2) + d;cba(3,2,1) + d;bac(2,1,3) )
%
% Now, to assess the magnitude of each NL effect (Kerr, THG, etc.) from
% light-graphene interaction, we conventionally evaluate the xxxx component 
% of symmetrized sigma3. To compute that in the THG case (f1=f2=f3), we 
% need only one permutation of the "dabc coord's", as it holds that the 
% SYMMETRIZED xxyy==xyxy==xyyx = 1/3*xxxx. For the Kerr case (-f,f,f) and
% the PFC cases, we need only three permutations.
%
% Finally, a note on the stability of the finite-temperature spectra using
% the smoothing formulas of Appendix B in [1]: In case of "noisy" or
% inaccurate spectra (e.g., trying to repro curves in [1]), consider 
% decreasing the "Es_stp" (step) variable below and/or increasing the
% "Es_max". Problems with noisy spectra appear due to the numerical
% integration (e.g., check Eqs.(B1),(B2),(B4) in [1]) and they are worse
% for low Gi and/or Ge, i.e., when Gie < 5 meV; low Ge is generally more 
% noise-prone. 
%
% [1] JinLuo Cheng (JLC), N. Vermeulen, J. E. Sipe, "Third-order 
%     nonlinearity of graphene: Effects of phenomenological relaxation and
%     finite temperature", PRB, 2015. 
%     >>> https://doi.org/10.1103/PhysRevB.91.235320
% [2] Sergey A. Mikhailov (SAM), "Quantum theory of the third-order 
%     nonlinear electrodynamic effects of graphene", PRB, 2016.
%     >>> https://doi.org/10.1103/PhysRevB.93.085403 
%
% Alexandros Pitilakis / Thessaloniki-Greece / July 2024
%
% GNU General Public License v3.0 | Copyright (c) 2024 Alexandros Pitilakis


% #### CRITICAL #####
% Energies for numerical integration/smoothing for finite-temperature. 
% Can greatly affect script's parametric speed (through the auxiliary G/H/I
% functions, implemented in the bettom of this function) but can also
% improve accuracy and "stability" of acquired spectra (remove noise)
global Es_max Es_stp 
Es_max = 2; % [eV] max/-min value, typically 2 eVs works fine
Es_stp = 1e-4; % [eV] step, should be 1e-3 or less (1e-4 for function-I).

% Constants definition
global e kB eps0 h hbar c0
h    = 6.62607e-34;    % [Joule*sec] Plank Constant
hbar = h/2/pi;         % [Joule*sec] Reduced Plank Constant
c0   = 299792458;      % [m/sec] Speed of Light in free-space
e    = 1.60217663e-19; % [C] Electron charge
eps0 = 8.85418781e-12; % [F/m] Vaccuum Permittivity
kB   = 1.38064852e-23; % [J/K] Boltzmann Constant

% Graphene-specific constants
a0  = 2.46e-10; % [m] graphene lattice constant, 2.46 Angstrom
g0  = 2.7 * e;  % [J] nearest-neighbour coupling energy
vF  = sqrt(3)*a0*g0/2/hbar; % [m/s] Fermi velocity in graphene, ~1e6 = c0/300
s0  = e^2 / 4 / hbar; % [S] "universal" opt. conductivity of graphene ~ 61 uS
dgr = 0.3e-9; % [m] effective graphene thickness (unused)

% Vocalize progress (to MATLAB CMD)
DoVoc = 1;
if nargin == 0
    DoVoc = 1;
end

% ====== Test inputs ======
if nargin == 0
    clc; close all;       
    
    % Parameters below reproduce THG case of Fig. 3(b), blue curves (300 K)
    Temp = 300; % [K]
    omega = linspace(0.1,1,100)*e/hbar;  % [rad/sec], converted from eV
    mu_eV = 0.3; % [eV] chemical potential (doping) of graphene
    Gi_eV = 33e-3; % [eV] intraband relaxation energy, tau=hbar/(G_eV*e)
    Ge_eV = 33e-3; % [eV] interband relaxation energy

   % === Formulas: 'Simple', 'Full', 'Full_xxxx' (last is default)
    s3_Formulas = 'Full_xxxx'; 
    
    % === Sigma3 Mode: 'Kerr', 'THG', 'PFC', 'KerrDetune' (last is default)
    myMode = 0;
    switch myMode
        case 0, s3_Mode = 'THG'; omegaT = 3*omega;
        case 1, s3_Mode = 'Kerr'; omegaT = omega;
        case 2, 
            s3_Mode = 'KerrDetune'; 
            dKD = 1 - 1e-3; % apply a detuning in (-d,1,1) to avoid NaNs
            omegaT = (2-dKD)*omega;
        case 3,
            s3_Mode = 'PFC'; % Parametric Frequency Conversion
            omp = 0.8 *e/hbar; % [rad/sec] from [eV], for PFC: s3(-om_s,+om_p,+om_p)
            omegaT = 2*omp - omega;
    end
        
    % For NARGIN==0 plots (see below, after computations)
    xax_expr = 'hbar*omega/e'; % expression for x-axis
    stp_expr = 'sigma3_xxxx / s0 * 1e19'; % expression for y-axis
    yLim = 1e3*[-1.8,2.4];
    
end
% =========================

% Error check, input arguments
s3Fs = {'Full_xxxx','Full','Simple'}; isval = 0;
for ii=1:length(s3Fs)
    if strcmp( s3_Formulas, s3Fs{ii} ), isval = 1; end
end
if isval == 0, 
    s3_Formulas
    error( ' ## Invalid s3_Formulas string! (Valid: Full_xxxx, Full, Simple)');
end

s3Ms = {'THG','Kerr','KerrDetune','PFC'}; isval = 0;
for ii=1:length(s3Ms)
    if strcmp( s3_Mode, s3Ms{ii} ), isval = 1; end
end
if isval == 0, 
    s3_Mode
    error( ' ## Invalid s3_Mode string! (Valid: THG, Kerr, KerrDetune, PFC)');
end


% Apply some defaults
if ~exist( 'dKD', 'var' ) && strcmp( s3_Mode , 'KerrDetune' )
    try
        dKD = evalin( 'base' , 'dKerrDetune' );
        if DoVoc==1, 
            disp( ' ** KerrDetune: Picked "dKD" from workspace' ); 
        end
    catch
        dKD = 1 - 1e-4; % [.] unitless detuned-Kerr parameter (-d,1,1)*omega
        if DoVoc==1, 
            disp( ' ** KerrDetune: Assigned "dKD" to a fixed value' )
        end
    end
end
if ~exist( 'omp' , 'var' ) && strcmp( s3_Mode , 'PFC' )
    omp = 0.8 *e/hbar; % [rad/sec] pump wavelength in Par-Freq-Conv
    if DoVoc==1, 
        disp( ' ** PFC: Set omega pump to a default value (0.8 eV)' ); 
    end
end

% Finite-temperature warning
if (Es_max < 1.5*max(mu_eV) || Es_max < 1.5*max( omega*hbar/e )) && DoVoc==1
   disp( ' ## Warning (Finite temperature): Too high |mu| or omega! Incr. Es_max' ) 
end

% Finite-temperature stuff for G/H/I misc-functions (these work as the 
% "default" values, assumed in the Temp-relates input-args ar eundefined)
global Tf FZTf
Tf   = Temp; % Temperature "fixed" (default)
FZTf = 1*((Tf == 0)); % ForceZeroTemp "fixed" (if Tf==0) 
if ~exist( 'FZT' , 'var' )
    FZT = FZTf; % boolean: Force Zero Temp (in G/H/I misc-function calcs)
end

% #########################################################################
% Prelim calcs & Tests
% #########################################################################

% For parametric sweeps, best to define these "gridded" params
% ### This has not been fully automated. So, it actually works only for:
%     * Temp  --> Scalar
%     * mu    --> Vector or Scalar
%     * omega --> Scalar or Vector
%     i.e., Temp is always scalar and mu/omega can't be both Vector.
if numel(Temp) > 1, error( ' ## Temp must be scalar!' ); end
if numel(omega)>1 && numel(mu_eV)>1,
    error( ' ## Omega and mu_eV can''t both be vector!' ); 
end
[omg,mug,Tg] = ndgrid( omega , mu_eV, Temp );

% === Linear conductivity sigma1 ===
%  (at given Temp. and relaxations)
if nargout == 2
    if Temp > 0

        % === Finite-Temp. "smoothing" of term: J=|mu|/(hv+1j*Gi) ===
        E = -Es_max:Es_stp:+Es_max; % [eV] sample energies for "smoothing" integral
        [omgg,mugg,Tgg,Egg] = ndgrid( omega*hbar/e, mu_eV, Temp*kB/e, E );
        J0 = abs(Egg)./(omgg+1i*Gi_eV); % J-funct at Temp=0 with mu-->Egg 
        JT = 1./ Tgg(:,:,:,1) .* trapz( E , J0 ./( 2 + 2*cosh( (Egg-mugg)./Tgg ) ) , 4 );

        % Finite-temp
        sigma1_xx = 1i*s0/pi*( 4*JT ...
            - funG(mu_eV , hbar/e*omega+1i*Ge_eV , Temp , 0 ) );
    else

        % Zero-temp version
        sigma1_xx = 1i*s0/pi*( 4*mug./(hbar/e*omg+1i*Gi_eV) ...
            - funG(mu_eV , hbar/e*omega+1i*Ge_eV , 0 , 1 ) );
    end
    
end

% Check for some limit-cases
if any(Tg(:)>0) && Gi_eV == 0 && Ge_eV == 0
    disp(' ** Finite Temp. and no-relaxation ==> sigma3 diverges!' );
    sigma3_xxxx = NaN*omg;
    return
end


% #########################################################################
% Main Function
% #########################################################################


% Constant "vectors" for the three independent components of the
% UNSYMMETRIZED sigma3_tensor. For the "xxxx" component, one needs to sum 
% xxyy+xyxy+xyyx (applies for SYM and UNSYM sigma3 tensor).
% This is the "per-tensor-component" ii-iteration in the "Full" formulas,
% which is collapsed into a single iteration for the Full_xxxx-only case,
% by replacing Ai vectors with scalas, Ai-->sum(Ai), i=0,1,2,3
A1 = [-3;+1;+1];
A2 = [+1;-3;+1];
A3 = [+1;+1;-3];
A0 = [+1;+1;+1]; % Note that A0 = -(A1+A2+A3);

% Short-hand variables
s3 = s0 * ( hbar *vF*e)^2 / pi / e^4; % [S*(m/V)^2]*[eV^4]

% ================ Simple Kerr (+TPA/SA) case ================
if strcmp( s3_Formulas , 'Simple' ) && strcmp( s3_Mode, 'Kerr')
    
    if DoVoc==1
        disp('Using Simplified Kerr formulas, Eqs.(58)-(62)')
    end
    
    % 1D vectors (for inputs to AuxFuncts G/H/I)
    hv  = hbar * omega /e; % [eV] hbar * omega
    thp = +hv + 1i *Ge_eV; % [eV] "theta_plus"
    thm = -hv + 1i *Ge_eV; % [eV] "theta_minus"
    nup = +hv + 1i *Gi_eV; % [eV] "nu_plus"
    num = -hv + 1i *Gi_eV; % [eV] "nu_minus"
    
    % Gridded (up to 3D) vectors -- for parametric sweeps
    hvg  = hbar * omg / e;   % [eV] same as hv, but in 3D-grid
    thpg = +hvg + 1i *Ge_eV; % [eV] "theta_plus"
    thmg = -hvg + 1i *Ge_eV; % [eV] "theta_minus"
    nupg = +hvg + 1i *Gi_eV; % [eV] "nu_plus"
    numg = -hvg + 1i *Gi_eV; % [eV] "nu_minus"
    
    % Kerr-effect parameters (self-modulation)
    L1 = NaN*zeros( length(omega), length(mu_eV), length(Temp) , 3 );
    L2 = NaN*zeros( length(omega), length(mu_eV), length(Temp) , 3 );
    L3 = NaN*zeros( length(omega), length(mu_eV), length(Temp) , 3 );
    L4 = NaN*zeros( length(omega), length(mu_eV), length(Temp) , 3 );
    for ii = 1 : 3
        
        fprintf( ' Step %d of 3\n' , ii )
        
        L1(:,:,:,ii) = 1i*s3*A0(ii)./( 12 * hvg.^2 ) .* ...
            ( +funG( mu_eV , thp , Temp , FZT ) ...
              +funG( mu_eV , thm , Temp , FZT ) );
        
        L2(:,:,:,ii) = s3*A0(ii)./( 12 * hvg .^2 ) .* ...
            ( ...
            +thpg./thmg.^2 .* funG( mu_eV , thm , Temp , FZT) ...
            +(5*thpg.^2 - 3*thmg.^2)./(2*thpg.^3) .* funG( mu_eV , thp , Temp , FZT)...
            +2*hvg./thpg.^2 .* (...
                +hvg.*funH( mu_eV, thp , Temp, FZT)...
                +4.*Ge_eV.^2./(thmg.*abs(mug))...
                )...
            );
        
        L3(:,:,:,ii) = s3*Gi_eV./( 6 *hvg.^2 .* nupg ) .* ...
            ( ...
            +1i*(A0(ii)-A1(ii))*funG( mu_eV , 0*thp+1i*Ge_eV , Temp , FZT)...
            -Gi_eV*Ge_eV./( abs(mug).*(4*mug.^2 + Ge_eV^2).*nupg ) .* ...
            ( A1(ii) + A0(ii) + 2*nupg./numg*A1(ii) ) );
        
        L4(:,:,:,ii) = 1i*s3./( 12 *hvg.^4 ) .* ...
            ( ...
            +( 2*A1(ii)-2*A0(ii))*funG( mu_eV , 0*thp+1i*Ge_eV , Temp , FZT) ...
            +(12*A1(ii)+4*A0(ii))*funG( mu_eV , thp , Temp , FZT) ...
            -( 4*A1(ii)+5*A0(ii))*funG( mu_eV , thm , Temp , FZT) ...
            -( 8*A1(ii)+8*A0(ii))*funG( mu_eV , 2*hv+1i*Ge_eV , Temp , FZT) ...
            -4*mug.*hvg.^2 ./( thpg.^2 - 4*mug.^2 ).^2 .* (...
            +(A1(ii)+4*A0(ii))*thpg + A0(ii)*( thpg.^2 - 4*mug.^2 )./ hvg )...
            );
    end
    
    % Final expression
    sigma3_xxxx = sum( L1/Gi_eV/Ge_eV + L2/Gi_eV + L3/Ge_eV + L4 , 4);
    
end
        
% ================ Simple THG (w/ low-Gamma) case ================
if strcmp( s3_Formulas , 'Simple' ) && strcmp( s3_Mode, 'THG')
    
    if DoVoc==1
        disp('Using Simplified THG formulas (Gi,Ge<<hf), , Eqs.(51)-(52)')
    end
    
    % Shorthand variables, as 1D vectors (for inputs to funs G/H/I)
    omega = omega(:);
    hv    = hbar * omega /e; % [eV] omega
    mu    = abs(mu_eV); % [eV] 
    mug   = abs(mu_eV)*ones(size(hv)); % [eV] grid (for hv parametrics)
    
    % Assuming G_i and G_e <<hv we can have three terms only:
    s3Axxyy = ... % Terms depending on G-function
        1i*s3./(144*hv.^4).*(...
        +17*funG(mu,1*hv+1i*Ge_eV) ...
        -64*funG(mu,2*hv+1i*Ge_eV) ...
        +45*funG(mu,3*hv+1i*Ge_eV) ...
        );
    s3Bxxyy = ... % Terms depending on H- and I-functs
        s3*Gi_eV./(36*hv.^4).*(...
        -08*funH(mu,2*hv+1i*Ge_eV) ...
        +17*funH(mu,3*hv+1i*Ge_eV) ...
        +03*funI(mu,3*hv+1i*Ge_eV).*hv ...
        );
    s3Cxxyy = ... % Termcs depending on 1/|mu|
        -2i*s3*( Gi_eV - Ge_eV)^2 ./ ( 27*hv.^5.*mug );
    
    % The total xxxx is three times xxyy (cuz xxyy=xyyx=xyxy)
    % (Also,for THG, symmetrized == unsymmetrized)
    sigma3_xxxx = 3*(s3Axxyy+s3Bxxyy+s3Cxxyy);
    
end

% ================ Full (Generic) case ================
if strcmp( s3_Formulas , 'Full' )
    
    if DoVoc==1
        disp(['Using Full S1..S8 terms, Eqs. (19)-(26) in ',s3_Mode,' (non-xxxx) Mode'])
    end
    
    % Define frequency mixtures/permutations. 
    % For Kerr, f --> {-f,+f,+f} and {+f,-f,+f} and {+f,+f,-f} 
    omega = omega(:);
    if strcmp( s3_Mode, 'Kerr' )    
        om1 = omega*[-1 +1 +1];
        om2 = omega*[+1 -1 +1];
        om3 = omega*[+1 +1 -1];
        Nperms = 3;
    elseif strcmp( s3_Mode, 'KerrDetune' ) 
        om1 = omega*[-dKD +1 +1];
        om2 = omega*[+1 -dKD +1];
        om3 = omega*[+1 +1 -dKD];
        Nperms = 3;
    elseif strcmp( s3_Mode, 'THG' )    
        om1 = +omega;
        om2 = +omega;
        om3 = +omega;
        Nperms = 1;
    elseif strcmp( s3_Mode, 'PFC' )    
        om1 = [-omega      ,  omp+0*omega , omp+0*omega ];
        om2 = [omp+0*omega , -omega       , omp+0*omega ];
        om3 = [omp+0*omega ,  omp+0*omega , -omega      ];
        Nperms = 3;
    end
    om0 = om2 + om3; % sum of 2 and 3
    omV = om1 + om2 + om3; % variable "omega" in paper (algebraic sum)
    
    % Iterate over required frequency permutations. 
    % First, prepare the per-permut matrices
    clear S1p S2p S3p S4p S5p S6p S7p S8p
    S1p=0; S2p=0; S3p=0; S4p=0; S5p=0; S6p=0; S7p=0; S8p=0; 
    
    S1p=zeros(size(mug)); 
    S2p=zeros(size(mug)); 
    S3p=zeros(size(mug));
    S4p=zeros(size(mug)); 
    S5p=zeros(size(mug)); 
    S6p=zeros(size(mug)); 
    S7p=zeros(size(mug)); 
    S8p=zeros(size(mug));
    
    for np = 1 : Nperms
        
        if DoVoc==1
        fprintf('Frequency permutation %d of %d\n' , np , Nperms );
        end
    
        % Shorthand variables, as 1D vectors (for inputs to funs G/H/I)
        hv   = hbar * omV(:,np) /e; % [eV] omV = algebraic sum of om_{1,2,3}
        hv3  = hbar * om3(:,np) /e; % [eV] 
        hv0  = hbar * om0(:,np) /e; % [eV] sum: om2+om3 | Can be zero in Kerr!
        mu   = abs(mu_eV); % [eV]

        mug   = abs(mu_eV)*ones(size(hv)); % [eV] pseudo-grid (for hv plots)

        % "Theta" are inputs to G/H/I and contain the INTERband relax-rate
        th = hv  + 1i*Ge_eV; % [eV] "theta"  at omV=om1+om2+om3
        t0 = hv0 + 1i*Ge_eV; % [eV] "theta0" at om0=om2+om3
        t3 = hv3 + 1i*Ge_eV; % [eV] "theta3" at om3
        t1 = th - t0; % [eV] "theta1" at omV-om0 = omega1 (imags cancel out)
        t2 = t0 - t3; % [eV] "theta2" at omV-om3 = omega2 (imags cancel out)

        % "Nu" just divide the S_{1...8} and contain the INTRAband relax-rate
        nu = hv  + 1i*Gi_eV; % [eV] "nu"  at omV=om1+om2+om3
        n0 = hv0 + 1i*Gi_eV; % [eV] "nu0" at om0=om2+om3
        n3 = hv3 + 1i*Gi_eV; % [eV] "nu3" at om3

        % S_{1...8} components of sigma_3 (generic expressions)
        % Now, prepare the per-tensor-component sum-matrices
        clear S1 S2 S3 S4 S5 S6 S7 S8
        S1=0; S2=0; S3=0; S4=0; S5=0; S6=0; S7=0; S8=0;
        
        S1=zeros(size(mug)); 
        S2=zeros(size(mug)); 
        S3=zeros(size(mug));
        S4=zeros(size(mug)); 
        S5=zeros(size(mug)); 
        S6=zeros(size(mug)); 
        S7=zeros(size(mug)); 
        S8=zeros(size(mug));
        
        for ii = 1 : length(A1) % iteration "per tensor component"
            
            if DoVoc==1
            fprintf('  Tensor-Component %d (of 3)\n' , ii );
            end

            % S1...S5, relatively "tame", no divergences (NaNs)
            S1(:,ii)= ...S1+...
                A0(ii) ./ mug;

            S2(:,ii)= ...S2+...
                A0(ii) .* ( funG(mu,t3) ./ t3.^2 - 1 ./ mug ./ t3 );

            S3(:,ii)= ...S3+...
                A3(ii) .* ( funH(mu,t0) ./ t0.^1 - 1 ./ mug ./ t0 );

            S4(:,ii)= ...S4+...
                -funG(mu,t3) .* ( t3*A2(ii) + t2*A3(ii) )./ (t2.*t3).^2 ...
                +funG(mu,t0) .* ( t0*A2(ii) + t2*A2(ii) + t2*A3(ii) )./ (t0.*t2).^2 ...
                -funH(mu,t0) .* A2(ii) ./ ( t0.*t2 ) ...
                + A3(ii) ./ mug ./ t0 ./ t3;

            S5(:,ii)= ...S5+...
                +funH(mu,th) .* A0(ii) ./ th...
                +funI(mu,th) .* A1(ii)...
                -A0(ii)./mug./th;

            % S6
            % For Kerr, unsymmetrized (-,+,+) and (+,-,+) ==> th==t3.
            % So, we have divergences (NaN error) here from th-t3==0. 
            % But, first two terms cancel out, so that was easy!
            if strcmp(s3_Mode,'Kerr') && any( np == [1,2] )
                S6(:,ii)= ...S6+...
                     +A0(ii)./mug./th./t3;
            else            
                S6(:,ii)= ...S6+...
                    -funG(mu,t3).*th*A0(ii)./( (th.*t3).^2 - t3.^4 )...
                    +funG(mu,th).*t3*A0(ii)./( th.^4 - (th.*t3).^2 )...
                    +A0(ii)./mug./th./t3;
            end

            % S7 is also "tame"
            S7(:,ii)= ...S7+...
                +funH(mu,t0).*( A2(ii)./t1.^2  - A3(ii)./t0./t1)...
                +funH(mu,th).*( A3(ii)./th./t1 - A2(ii)./t1.^2 )...
                -funI(mu,th).*A2(ii)./t1...
                + A3(ii)./mug./th./t0;

            % S8, aka "big guy"
            % True Kerr (-,+,+) and (+,-,+) ==> th==t3, t2=-t1=+/-hù, and
            % t0=2hù+iG or t0=iG. The (th-t3)=0 gives divergences (NaNs),
            % but thankfully:
            % (1) Terms 1-vs-5 and 2-vs-6 cancel out (for np=1 and np=2)
            % (2) Terms 8-vs-9 also cancel out between np=1 and np=2
            % So, when in Kerr mode, for np=1 (-,+,+) and np=2 (+,-,+) we
            % leave out the terms (1,2,5,6,8,9). For np=3 (+,+,-) it is
            % safe to use the full expressions (no NaNs).
            if strcmp(s3_Mode,'Kerr') && any( np == [1,2] )
                S8(:,ii)= ...S8+...
                    +funG(mu,t0).*( ... % Terms 3 and 4 ("tame")
                        -A2(ii).*( t0.*t1 + t1.*t2 - t0.*t2 ) ./ (t0.*t1.*t2).^2 ...
                        -A3(ii).*( t1.*t2 - t0.^2 - t0.*t2 ) ./ (t0.*t1.*t2).^2 ...
                        )...
                    +funH(mu,t0).*( ... % Term 7 (also safe)
                        +A2(ii) ./ ( t0 .* t1 .* t2 )...
                        -A3(ii) ./ ( t1.^2 .* t2 )...
                        )...
                    -A3(ii)./mug./th./t0./t3; % Term 10 (safe)
            else
                S8(:,ii)= ...S8+...
                    +funG(mu,t3).*( ... % Terms 1 and 2
                        +A2(ii)./( (th-t3).*t2.^2.*t3 )...
                        +A3(ii).*(th.^2.*t2 + t3.^3 + th.*t3.*(-3*t0 + 2*t3))./( (th-t3).^3 .* t2.^2 .* t3.^2 )...
                        )...
                    +funG(mu,t0).*( ... % Terms 3 and 4
                        -A2(ii).*( t0.*t1 + t1.*t2 - t0.*t2 ) ./ (t0.*t1.*t2).^2 ...
                        -A3(ii).*( t1.*t2 - t0.^2 - t0.*t2 ) ./ (t0.*t1.*t2).^2 ...
                        )...
                    +funG(mu,th).*( ... % Terms 5 and 6
                        -A2(ii)./( th.*t1.^2.*(th-t3) )...
                        -A3(ii).*( 5*th.^2 + t3.*(t0+t3) - th.*(3*t0+4*t3) )./ ( th.*t1.^2.*(th-t3).^3 )...
                        )...
                    +funH(mu,t0).*( ... % Term 7
                        +A2(ii) ./ ( t0 .* t1 .* t2 )...
                        -A3(ii) ./ ( t1.^2 .* t2 )...
                        )...
                    +funH(mu,th).*(... % Term 8
                        +A3(ii) .*( 4*th.^2 - 3.*th.*t0 - 2*th.*t3 + t0.*t3 )...
                                ./( th.*t1.^2.*(th-t3).^2 )...
                        )...
                    +funI(mu,th).*A3(ii) ./ t1 ./ (th-t3)... % Term 9
                    -A3(ii)./mug./th./t0./t3; % Term 10
            end

        end
        
        % NTe S1...S8 now hold the sums over "per-tensor-component" (ii)
        % for this permutation (np). So, apply the nu-normalization 
        % (note that the "nu" are different for each permutation [np], 
        % because the frequencies change, but same for each per-tensor-comp
        % [ii] iteration) and sum to the per-permutation global matrices.
        
        S1p = S1p + sum(S1,2) ./ nu ./ n0 ./ n3;
        S2p = S2p + sum(S2,2) ./ nu ./ n0;
        S3p = S3p + sum(S3,2) ./ nu ./ n3;
        S4p = S4p + sum(S4,2) ./ nu;
        S5p = S5p + sum(S5,2) ./ n0 ./ n3;
        S6p = S6p + sum(S6,2) ./ n0;
        S7p = S7p + sum(S7,2) ./ n3;
        S8p = S8p + sum(S8,2) ;         
    
    end
    
    % Average over number of permutations required
    S1p = S1p /Nperms;
    S2p = S2p /Nperms;
    S3p = S3p /Nperms;
    S4p = S4p /Nperms;
    S5p = S5p /Nperms;
    S6p = S6p /Nperms;
    S7p = S7p /Nperms;
    S8p = S8p /Nperms;       
    
    % Error checking    
    So(:,1) = +S1p;
    So(:,2) = +S2p;
    So(:,3) = +S3p;
    So(:,4) = +S4p;
    So(:,5) = +S5p;
    So(:,6) = +S6p;
    So(:,7) = +S7p;
    So(:,8) = +S8p;
    s3_xxxx = 1i*s3/s0 * 1e19 * So;
    if DoVoc==1
    disp( ' --- Checking S1..8 full-formula params ---' );
    for k=1:8
       fprintf( ' S%d (aver.) ~ Re = %+4.1e , Im = %+4.1e\n' , ...
           k, mean(real(s3_xxxx(:,k))), mean(imag(s3_xxxx(:,k))) ); 
    end
    end
        
    % Final **SYMMETRIZED** 3rd-order conductivity for sigma3_xxxx
    sigma3_xxxx = 1i*s3*(S1p+S2p+S3p+S4p+S5p+S6p+S7p+S8p);    
    
end

% ================ Full (xxxx-only) case ================
if strcmp( s3_Formulas , 'Full_xxxx' )
    
    if DoVoc==1
    disp(['Using ''Full'' S1..S8 terms, Eqs. (19)-(26), in ''',s3_Mode,''' xxxx-only Mode'])
    end
    
    % Define frequency mixtures/permutations. 
    % For Kerr, f --> {-f,+f,+f} and {+f,-f,+f} and {+f,+f,-f} 
    omega = omega(:);
    if strcmp( s3_Mode, 'Kerr' )    
        om1 = omega*[-1 +1 +1];
        om2 = omega*[+1 -1 +1];
        om3 = omega*[+1 +1 -1];
        Nperms = 3;
    elseif strcmp( s3_Mode, 'KerrDetune' ) 
        om1 = omega*[-dKD +1 +1];
        om2 = omega*[+1 -dKD +1];
        om3 = omega*[+1 +1 -dKD];
        Nperms = 3;
    elseif strcmp( s3_Mode, 'PFC' )    
        om1 = [-omega      ,  omp+0*omega , omp+0*omega ];
        om2 = [omp+0*omega , -omega       , omp+0*omega ];
        om3 = [omp+0*omega ,  omp+0*omega , -omega      ];
        Nperms = 3;
    elseif strcmp( s3_Mode, 'THG' )    
        om1 = +omega;
        om2 = +omega;
        om3 = +omega;
        Nperms = 1;
    end
    om0 = om2 + om3; % sum of 2 and 3
    omV = om1 + om2 + om3; % variable "omega" in paper (algebraic sum)
    
    % Iterate over required frequency permutations. 
    % First, prepare the per-permut matrices
    clear S1p S2p S3p S4p S5p S6p S7p S8p
    S1p=0; S2p=0; S3p=0; S4p=0; S5p=0; S6p=0; S7p=0; S8p=0;
    S6T = NaN * ones(Nperms, 3); % used in troubleshooting
    S8T = NaN * ones(Nperms,10); % used in troubleshooting   
    for np = 1 : Nperms
        
        if DoVoc==1
        fprintf(' == Frequency permutation %d of %d\n' , np , Nperms );
        end
    
        % Shorthand variables, as 1D vectors (for inputs to funs G/H/I)
        hv   = hbar * omV(:,np) /e; % [eV] omV = algebraic sum of om_{1,2,3}
        hv3  = hbar * om3(:,np) /e; % [eV] 
        hv0  = hbar * om0(:,np) /e; % [eV] sum: om2+om3
        mu   = abs(mu_eV); % [eV]

        % Chemical potential "pseudo-grid", appearing OUTSIDE 
        % the G/H/I fuctions, i.e., always as 1/|mu|, (used for hv plots)
        mug = abs(mu_eV)*ones(size(hv)); % [eV]
        if Temp > 0
            if DoVoc==1
            fprintf( '\b (using finite-Temp correction for 1/|mu|-divergence)\n' );
            end
            %mug = sqrt( mug.^2 + (kB*Temp/e).^2 ); % [eV] Eq. (36) in paper
            
            E = -Es_max:Es_stp:+Es_max; % [eV] sample energies for "smoothing" integral
            [omgg,mugg,Tgg,Egg] = ndgrid( omega*hbar/e, mu_eV, Temp*kB/e, E );
            J0 = 1./sqrt( (Egg).^2 + (kB*Temp/e).^2 ); % J-funct at Temp=0 with mu-->Egg 
            JT = 1./ Tgg(:,:,:,1) .* trapz( E , J0 ./( 2 + 2*cosh( (Egg-mugg)./Tgg ) ) , 4 );
            
            mug = 1./JT;
        end

        % "Theta" are inputs to G/H/I and contain the INTERband relax-rate
        th = hv  + 1i*Ge_eV; % [eV] "theta"  at omV=om1+om2+om3
        t0 = hv0 + 1i*Ge_eV; % [eV] "theta0" at om0=om2+om3
        t3 = hv3 + 1i*Ge_eV; % [eV] "theta3" at om3
        t1 = th - t0; % [eV] "theta1" at omV-om0 = omega1 (imags cancel out)
        t2 = t0 - t3; % [eV] "theta2" at omV-om3 = omega2 (imags cancel out)

        % "Nu" just divide the S_{1...8} and contain the INTRAband relax-rate
        nu = hv  + 1i*Gi_eV; % [eV] "nu"  at omV=om1+om2+om3
        n0 = hv0 + 1i*Gi_eV; % [eV] "nu0" at om0=om2+om3
        n3 = hv3 + 1i*Gi_eV; % [eV] "nu3" at om3

        % S_{1...8} components of sigma_3 (generic expressions)
        % In the xxxx-only mode, vectors A0...A3 degenerate to scalars
        % which equal their sums.
        clear S1 S2 S3 S4 S5 S6 S7 S8
        A1=-1; A2=-1; A3=-1; A0=3; ii=1;
        
        % S1...S5, relatively "tame", no divergences (NaNs)
        S1= A0(ii) ./ mug;

        S2= A0(ii) .* ( funG(mu,t3) ./ t3.^2 - 1 ./ mug ./ t3 );

        S3= A3(ii) .* ( funH(mu,t0) ./ t0.^1 - 1 ./ mug ./ t0 );

        S4= -funG(mu,t3) .* ( t3*A2(ii) + t2*A3(ii) )./ (t2.*t3).^2 ...
            +funG(mu,t0) .* ( t0*A2(ii) + t2*A2(ii) + t2*A3(ii) )./ (t0.*t2).^2 ...
            -funH(mu,t0) .* A2(ii) ./ ( t0.*t2 ) ...
            + A3(ii) ./ mug ./ t0 ./ t3;

        S5= +funH(mu,th) .* A0(ii) ./ th...
            +funI(mu,th) .* A1(ii)...
            -A0(ii)./mug./th;

        % S6
        % For Kerr, unsymmetrized (-,+,+) and (+,-,+) ==> th==t3.
        % So, we have divergences (NaN error) here from th-t3==0. 
        % But, first two terms cancel out, so that was easy!
        if strcmp(s3_Mode,'Kerr') && any( np == [1,2] ) %&& 0==1
            S6= +A0(ii)./mug./th./t3;
        else            
            S6= -funG(mu,t3).*th*A0(ii)./( (th.*t3).^2 - t3.^4 )...
                +funG(mu,th).*t3*A0(ii)./( th.^4 - (th.*t3).^2 )...
                +A0(ii)./mug./th./t3;
            
            if 1==0 %length(omega)==1
                S6T(np,1) = -funG(mu,t3).*th*A0(ii)./( (th.*t3).^2 - t3.^4 );
                S6T(np,2) = +funG(mu,th).*t3*A0(ii)./( th.^4 - (th.*t3).^2 );
                S6T(np,3) = +A0(ii)./mug./th./t3;
                S6T(np,:) = S6T(np,:) ./ n0;
                
                if np==3
                    S6T
                    inii = ~isinf( S6T(:) );
                    S6_InfNaNSum=sum(sum(S6T(1:2,1:2)))
                    S6T(1:2,1:2)=NaN;
                    S6T
                    S6final = 1/3*sum(S6T(inii))
                end
                %inii = ~isinf( S6T(np,: ) );
                %S6 = sum(S6T(np,inii))
                
            end
        end

        % S7 is also "tame"
        S7= +funH(mu,t0).*( A2(ii)./t1.^2  - A3(ii)./t0./t1)...
            +funH(mu,th).*( A3(ii)./th./t1 - A2(ii)./t1.^2 )...
            -funI(mu,th).*A2(ii)./t1...
            + A3(ii)./mug./th./t0;

        % S8, aka "big guy"
        % True Kerr (-,+,+) and (+,-,+) ==> th==t3, t2=-t1=+/-hù, and
        % t0=2hù+iG or t0=iG. The (th-t3)=0 gives divergences (NaNs),
        % but thankfully:
        % (1) Terms 1-vs-5 and 2-vs-6 cancel out (for ii=1 and ii=2)
        % (2) Terms 8-vs-9 also cancel out between ii=1 and ii=2
        % So, when in Kerr mode, for ii=1 (-,+,+) and ii=2 (+,-,+) we
        % leave out the terms (1,2,5,6,8,9). For ii=3 (+,+,-) it is
        % safe to use the full expressions (no NaNs).
        if strcmp(s3_Mode,'Kerr') && any( np == [1,2] )
            S8= +funG(mu,t0).*( ... % Terms 3 and 4 ("tame")
                    -A2(ii).*( t0.*t1 + t1.*t2 - t0.*t2 ) ./ (t0.*t1.*t2).^2 ...
                    -A3(ii).*( t1.*t2 - t0.^2 - t0.*t2 ) ./ (t0.*t1.*t2).^2 ...
                    )...
                +funH(mu,t0).*( ... % Term 7 (also safe)
                    +A2(ii) ./ ( t0 .* t1 .* t2 )...
                    -A3(ii) ./ ( t1.^2 .* t2 )...
                    )...
                -A3(ii)./mug./th./t0./t3; % Term 10 (safe)
          
        else
            S8= +funG(mu,t3).*( ... % Terms 1 and 2
                    +A2(ii)./( (th-t3).*t2.^2.*t3 )...
                    +A3(ii).*(th.^2.*t2 + t3.^3 + th.*t3.*(-3*t0 + 2*t3))./( (th-t3).^3.*t2.^2.*t3.^2 )...
                    )...
                +funG(mu,t0).*( ... % Terms 3 and 4
                    -A2(ii).*( t0.*t1 + t1.*t2 - t0.*t2 ) ./ (t0.*t1.*t2).^2 ...
                    -A3(ii).*( t1.*t2 - t0.^2 - t0.*t2 ) ./ (t0.*t1.*t2).^2 ...
                    )...
                +funG(mu,th).*( ... % Terms 5 and 6
                    -A2(ii)./( th.*t1.^2.*(th-t3) )...
                    -A3(ii).*( 5*th.^2 + t3.*(t0+t3) - th.*(3*t0+4*t3) )./ ( th.*t1.^2.*(th-t3).^3 )...
                    )...
                +funH(mu,t0).*( ... % Term 7
                    +A2(ii) ./ ( t0 .* t1 .* t2 )...
                    -A3(ii) ./ ( t1.^2 .* t2 )...
                    )...
                +funH(mu,th).*(... % Term 8
                    +A3(ii) .*( 4*th.^2 - 3.*th.*t0 - 2*th.*t3 + t0.*t3 )...
                            ./( th.*t1.^2.*(th-t3).^2 )...
                    )...
                +funI(mu,th).*A3(ii) ./ t1 ./ (th-t3)... % Term 9
                -A3(ii)./mug./th./t0./t3; % Term 10
            
            if 1==0 %length(omega)==1
                S8T(np,1) = +funG(mu,t3).*( ...
                    +A2(ii)./( (th-t3).*t2.^2.*t3 ) );
                S8T(np,2) = +funG(mu,t3).*( ...
                    +A3(ii).*(th.^2.*t2 + t3.^3 + th.*t3.*(-3*t0 + 2*t3))...
                    ./( (th-t3).^3.*t2.^2.*t3.^2 ));
                S8T(np,3)=+funG(mu,t0).*( ... 
                    -A2(ii).*( t0.*t1 + t1.*t2 - t0.*t2 ) ./ (t0.*t1.*t2).^2 );
                S8T(np,4)=+funG(mu,t0).*(...
                    -A3(ii).*( t1.*t2 - t0.^2 - t0.*t2 ) ./ (t0.*t1.*t2).^2 );
                S8T(np,5) = funG(mu,th).*( ... % Terms 5 and 6
                    -A2(ii)./( th.*t1.^2.*(th-t3) ) );
                S8T(np,6) = funG(mu,th).*( ...
                    -A3(ii).*( 5*th.^2 + t3.*(t0+t3) - th.*(3*t0+4*t3) )...
                    ./ ( th.*t1.^2.*(th-t3).^3 ) );
                S8T(np,7)=+funH(mu,t0).*( ... % Term 7
                    +A2(ii) ./ ( t0 .* t1 .* t2 )...
                    -A3(ii) ./ ( t1.^2 .* t2 )...
                    );
                S8T(np,8) = +funH(mu,th).*(... % Term 8
                    +A3(ii) .*( 4*th.^2 - 3.*th.*t0 - 2*th.*t3 + t0.*t3 )...
                            ./( th.*t1.^2.*(th-t3).^2 )...
                    );
                S8T(np,9)=+funI(mu,th).*A3(ii) ./ t1 ./ (th-t3); % Term 9
                S8T(np,10)=-A3(ii)./mug./th./t0./t3; % Term 10
                
                inii = ~isinf( S8T(np,: ) );
                S8 = sum(S8T(np,inii));
                
            end
                
        end

        
        % NTe S1...S8 now hold the sums over "per-tensor-component" (ii)
        % for this permutation (np). So, apply the nu-normalization 
        % (note that the "nu" are different for each permutation [np], 
        % because the frequencies change, but same for each per-tensor-comp
        % [ii] iteration) and sum to the per-permutation global matrices.
        S1p = S1p + S1 ./ nu ./ n0 ./ n3;
        S2p = S2p + S2 ./ nu ./ n0;
        S3p = S3p + S3 ./ nu ./ n3;
        S4p = S4p + S4 ./ nu;
        S5p = S5p + S5 ./ n0 ./ n3;
        S6p = S6p + S6 ./ n0;
        S7p = S7p + S7 ./ n3;
        S8p = S8p + S8 ;         
    
    end
    
    % Average over number of permutations required
    S1p = S1p /Nperms;
    S2p = S2p /Nperms;
    S3p = S3p /Nperms;
    S4p = S4p /Nperms;
    S5p = S5p /Nperms;
    S6p = S6p /Nperms;
    S7p = S7p /Nperms;
    S8p = S8p /Nperms;       
    
    % Error checking
    if 1==0
        So(:,1) = +S1p;
        So(:,2) = +S2p;
        So(:,3) = +S3p;
        So(:,4) = +S4p;
        So(:,5) = +S5p;
        So(:,6) = +S6p;
        So(:,7) = +S7p;
        So(:,8) = +S8p;
        s3_xxxx = 1i*s3/s0 * 1e19 * So;
        if DoVoc==1
        disp( ' --- Checking S1..8 full-formula params ---' );
        for k=1:8
           %fprintf( ' S%d (aver.) ~ Re = %+4.1e , Im = %+4.1e\n' , ...
           %    k, mean(real(s3_xxxx(:,k))), mean(imag(s3_xxxx(:,k))) ); 
           fprintf( ' S%d (aver.) ~ Re = %+4.1e , Im = %+4.1e\n' , ...
               k, mean(real(So(:,k))), mean(imag(So(:,k))) ); 
        end
        end
        S_12345678_Sum = sum(So)
    end
        
    % Final **SYMMETRIZED** 3rd-order conductivity for sigma3_xxxx
    sigma3_xxxx = 1i*s3*(S1p+S2p+S3p+S4p+S5p+S6p+S7p+S8p);    
    
end

% Clear-out results in some limit cases
if Temp==0 && Gi_eV == 0 && Ge_eV == 0 && numel(omega)==numel(mug)
    
    iii = omega(:)*hbar/e > 2.*mug(:);
    auxi = imag( sigma3_xxxx( iii ) );
    sigma3_xxxx( iii ) = Inf + 1i*auxi; % actually the Re diverges (NaN)
end

% ------------------- Post-proc & Plots ------------------
if nargin == 0
    
    % Evaluate y-axis and x-axis expressions for plotting
    xafp = eval( xax_expr ); % independent/par-sweeped param, mu or omega
    stp = eval( stp_expr ); % sigma3 spectra-to-plot, complex
    
    % For single param-set: Vocalize value in CMD
    if length(sigma3_xxxx)==1
        if isnan(stp), return; end
        disp(stp)
        return;
    end

    % Plot spectra
    plot( xafp , real(stp) , 'k-' , 'Linewidth' , 1.5 ); hold on;
    plot( xafp , imag(stp) , 'k--' , 'Linewidth' , 1.5 );
    
    % Cosmetics
    legend( 'Real' , 'Imag' )
    plot( xafp , 0*xafp , 'k-' );        
    try
        ylim( yLim );
    end
    xlim(xafp([1 end])); 
    ylabel( stp_expr , 'Interpreter' , 'none' );
    xlabel( xax_expr , 'Interpreter' , 'none' );
    
    if numel(omega)>1, parSwStr = sprintf( 'mu = %3.1f eV' , mu_eV );
    elseif numel(mu_eV)>1, parSwStr = sprintf( 'omega = %3.1f eV' , omega*hbar/e );
    else, parSwStr = [];
    end        
    subtit = sprintf( 'Temp = %d K | (Gi,Ge) = (%3.1f,%3.1f) meV | %s ' , ...
        round(Temp) , [Gi_eV,Ge_eV]*1e3 , parSwStr );    
    
    title( {[s3_Formulas,' | ',s3_Mode],subtit} , 'Interpreter' , 'none' )
    
    
    
    
end


% #########################################################################
% End of Main Function / Below follow auxiliary functions
% #########################################################################
end

% === AUX_FUNCT #1# : G, Eqs. (12)+(B1) in [1] ===
function G = funG( mu_eV , theta_eV , Temp , AssumeZeroTemp)

global FZTf Tf

if nargin < 4, AssumeZeroTemp = FZTf; end
if nargin < 3, Temp = Tf; end

% Argument "theta" must be passed in [eV]

% Constants
global e kB Es_max Es_stp


% Simple case: Assume quasi-zero Temp (==> No "smoothing" correction)
if AssumeZeroTemp == 1
    [thg,mug,Tg] = ndgrid( theta_eV, mu_eV, Temp*kB/e );
    %     x = thg ./ ( 2*abs(mug) );
    %     G = log( abs( (1+x)./(1-x) ) ) + 1i*( pi ...
    %         + atan( (real(x)-1)./(imag(x)) )...
    %         - atan( (real(x)+1)./(imag(x)) )...
    %         );
    G = log( abs( (2*abs(mug)+thg)./(2*abs(mug)-thg) ) ) + 1i*( pi ...
        + atan( (real(thg)-2*abs(mug))./(imag(thg)) )...
        - atan( (real(thg)+2*abs(mug))./(imag(thg)) )...
        );
    
    return
end

% Define 4D-grids for the various parameters ==> all in [eV] <== !!!
E = -Es_max:Es_stp:+Es_max; % [eV] sample energies for "smoothing" integral
[thg,mug,Tg,Eg] = ndgrid( theta_eV, mu_eV, Temp*kB/e, E );


% G-funct at zero-temperature, for each Eg (not mu!)
G0 = log( abs( (2*abs(Eg)+thg)./(2*abs(Eg)-thg) ) ) + 1i*( pi ...
    + atan( (real(thg)-2*abs(Eg))./(imag(thg)) )...
    - atan( (real(thg)+2*abs(Eg))./(imag(thg)) )...
    );

% Finite temperature correction ("smoothing")
G = 1./ Tg(:,:,:,1) .* trapz( E , G0 ./( 2 + 2*cosh( (Eg-mug)./Tg ) ) , 4 );

end

% === AUX_FUNCT #2# : H, Eqs. (27)+(B2) in [1] ===
function H = funH( mu_eV , theta_eV , Temp , AssumeZeroTemp)

global FZTf Tf

if nargin < 4, AssumeZeroTemp = FZTf; end
if nargin < 3, Temp = Tf; end

% Argument "theta" must be passed in [eV]

% Constants
global e kB Es_max Es_stp

% Simple case: Assume quasi-zero Temp (==> No "smoothing" correction)
if AssumeZeroTemp == 1
    [thg,mug,Tg] = ndgrid( theta_eV, mu_eV, Temp*kB/e );
    
    H = 1./( 2*abs(mug) - thg ) + 1./( 2*abs(mug) + thg );
    
    return
end

% Define 4D-grids for the various parameters ==> all in [eV] <== !!!
E = -Es_max:Es_stp:+Es_max; % [eV] sample energies for "smoothing" integral
[thg,mug,Tg,Eg] = ndgrid( theta_eV, mu_eV, Temp*kB/e, E );

% H-funct at zero-temperature, for each Eg (not mu!)
H0 = 1./( 2*abs(Eg) - thg ) + 1./( 2*abs(Eg) + thg );

% Finite temperature correction ("smoothing")
H = 1./ Tg(:,:,:,1) .* trapz( E , H0 ./( 2 + 2*cosh( (Eg-mug)./Tg ) ) , 4 );

end

% === AUX_FUNCT #3# : I, Eqs. (28)+(B4) in [1] ===
function I = funI( mu_eV , theta_eV , Temp , AssumeZeroTemp)

global FZTf Tf

if nargin < 4, AssumeZeroTemp = FZTf; end
if nargin < 3, Temp = Tf; end

% Argument "theta" must be passed in [eV]

% Constants
global e kB Es_max Es_stp

% Simple case: Assume quasi-zero Temp (==> No "smoothing" correction)
if AssumeZeroTemp == 1
    [thg,mug,Tg] = ndgrid( theta_eV, mu_eV, Temp*kB/e );
    
    I = 1./( 2*abs(mug) + thg ).^2 - 1./( 2*abs(mug) - thg ).^2;
    
    return
end

% Define 4D-grids for the various parameters ==> all in [eV] <== !!!
E = -Es_max:Es_stp:+Es_max; % [eV] sample energies for "smoothing" integral
[thg,mug,Tg,Eg] = ndgrid( theta_eV, mu_eV, Temp*kB/e, E );

% H-funct at zero-temperature, for each Eg (not mu!)
I0 = 1./( 2*abs(Eg) + thg ).^2 - 1./( 2*abs(Eg) - thg ).^2;

% Finite temperature correction ("smoothing")
I = 1./ Tg(:,:,:,1).* trapz( E , I0 ./( 2 + 2*cosh( (Eg-mug)./Tg ) ) , 4 );

end




